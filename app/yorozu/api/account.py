from rest_framework import status, views
from rest_framework.response import Response
from ..serializers.serializer_account import AccountSerializer
from ..models import Account


# アカウントモデルの詳細(yorozuIDのみ表示)
class AccountRetrieveAPIView(views.APIView):
    def get(self, request, pk):
        queryst = Account.objects.get(id=pk)
        return Response(queryst.profile.yorozu_id, status=status.HTTP_200_OK)


class AccountCreateAPIView(views.APIView):
    def post(self, request):

        serializer = AccountSerializer(data=request.data)
        serializer.is_valid()
        if serializer.is_valid():
            serializer.save()
            return Response({"アカウント作成成功"}, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


# class AccountViewSet(viewsets.ModelViewSet):

#     serializer_class = AccountSerializer
#     queryset = Account.objects.all()

#     # jwtの場合、これは使わなくなるのかな..
#     # permission_classes = (IsAuthenticated,)

# ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
# authenticationは認証で、そのトークンがデータベースにあるかどうかを判断
# permissionは、そのユーザーがログインしてあるユーザかどうか判断
# プロフィルールなど、他の人に、編集やら削除されないために、pemisttiionをつける
# ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

# ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
# Nginx guniconに関して
# アプリケーションは、ソケットを通じて、カーネルとやり取りをして、カーネルはインターネットに
# 接続されたハードウェアを通じて通信を行う。
# ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

# ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
# なぜ,NginxとGunicornが必要なのか

# 高速な静的ファイル配信とか省メモリであるとかが必要だからです。Pythonって結構メモリを食う。
# メモリ=>短期データアクセスを可能にするもの（電源を消せば消えるデータ）
# なので、静的ファイルを送るためにPythonを起動していると大変なので、
# NginxとかApacheに任せちゃう。

# ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

# ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
# Nginxがなぜ必要か
# スローリード攻撃というのがあって、レスポンスをのんびり読み取るクライアントがたくさんいると、
# それだけでワーカーが100個あっても全部使われてしまって、次のリクエストを受け取れないことに
# なったりするので、そういうのをバツっと切ってくれる機能がNginxとかにある。
# ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝


# ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
# Gunicornがなぜ必要か

# GunicornはWSGIに対応したWebアプリケーションサーバーなんですが、マルチプロセスで
# 動作するので並行処理ができます。
# 親プロセスがHTTPリクエストを受け取って、多重起動したワーカープロセスにどんどん
# リクエストを渡していきます。また、親プロセスで起動したワーカープロセスが死んだら、
# 立ち上げ直してくれます。先ほどデモしている途中でプログラムが落ちたりしていましたが、
# Gunicornを使っていれば、落ちたらまた起動してくれます。
# このへんを自分で実装するのは結構大変だし、自分で書いたら性能が大抵良くないんですが
# GunicornやuWSGIを使えば、自分で実装しなくて済みます。

# ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝


# ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
# webサーバーとアプリケーションサーバー
# Webサーバーでは、同じリクエストがあった場合、同じコンテンツを配信するようにキャッシュの
# 設定することができます。このメリットとして、アプリケーションサーバーに問い合わずにコンテンツを
# 返すので、高速配信が可能ですし、大量のリクエストがあったときにも対応することができます。
# 一方で、アプリケーションサーバーでは、アクセスごとに内容を変更する可能性があるので、
# 毎回毎回コンテンツを生成します。そのため、コンテンツのキャッシュ機能はあまり使われません。
# ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

# ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
# アプリケーションサーバー
# APサーバは、Webサーバから受けたリクエストをもとにpythonやRunyなどで作成された
# アプリケーションを実行して動的コンテンツを生成します
# ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

# ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
# localでは、djangoがサーバーを持っていて、画像もプログラムも実装してしていたが、
# ユーザーをたくさん捌くに当たっては、別の方法が取られる。そこで、nginxを活用する。
# nginx自体にAppサーバの機能は無く、nginx(Webサーバ)とAppサーバを組み合わせることで、
# １台のWeb兼Appサーバとして動作する。

# なので、nginxの設定ファイルには、nginxから、applicationサーバーに繋ぐ設定を書かないと
# いけない
# ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

# ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
# 安定的なサーバーを作るまでの過程
#(1)開発環境では、クライアントからdjangoにアクセスして、pythonの内蔵サーバーで表示
#(2)より安定的なサーバーを使うためgunicornを採用
#(3)gunicornは、pythonファイル以外は別のサーバーで処理をしたいので、Nginxを使う
# ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

# ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
# gunicornに関して
# gunicornは、単体でアプリケーションを動かすアプリにもなるし、他のwebサーバー(Nginx)との
# 連係をできるような作りになっている。なぜ、runserverでなく、gunicornを使うかといえば、
# 動作が速いから。なぜ早いかと言えば、マルチプロセスで動作するから
# ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

